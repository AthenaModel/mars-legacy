# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    sqlib.test
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    Tcltest test suite for marsutil(n) sqlib.tcl
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Initialize tcltest(n)

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.2 
    eval ::tcltest::configure $argv
}
 
#-----------------------------------------------------------------------
# Load the package to be tested

package require sqlite3
package require marsutil 1.0

#-----------------------------------------------------------------------
# Test Suite
#
# The tests run in a namespace so as not to interfere with other
# test suites.

namespace eval ::marsutil::test {
    #-------------------------------------------------------------------
    # Set up the test environment

    # Import tcltest(n)
    namespace import ::tcltest::*

    # Import the code to be tested
    namespace import ::marsutil::*

    # Define variables
    set db  ::marsutil::test::db
    set db2 ::marsutil::test::db2

    #-------------------------------------------------------------------
    # tables

    test tables-1.1 {Lists persistent tables} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            CREATE TABLE second(d,e,f);
        }
    } -body {
        sqlib tables $db 
    } -cleanup {
        $db close
    } -result {first second sqlite_sequence}

    test tables-1.2 {Lists temporary tables} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            CREATE TABLE second(d,e,f);
            CREATE TEMP TABLE third(g,h,i);
        }
    } -body {
        sqlib tables $db 
    } -cleanup {
        $db close
    } -result {first second sqlite_sequence third}

    test tables-1.3 {Lists attached tables} -setup {
        sqlite3 $db  :memory:
        sqlite3 $db2 test.db

        $db2 eval {
            CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            CREATE TABLE second(d,e,f);
        }

        $db eval {
            CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            CREATE TABLE second(d,e,f);
            ATTACH DATABASE 'test.db' AS test;
        }
    } -body {
        sqlib tables $db 
    } -cleanup {
        $db close
        $db2 close
        removeFile test.db
    } -result {first second sqlite_sequence test.first test.second test.sqlite_sequence}

    #-------------------------------------------------------------------
    # schema

    test schema-1.1 {Lists persistent schema} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            CREATE TABLE second(d,e,f);
            CREATE INDEX first_index ON first(a,b);
            CREATE VIEW third AS SELECT d,e FROM second;
        }
    } -body {
        sqlib schema $db 
    } -cleanup {
        $db close
    } -result {CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);

CREATE TABLE sqlite_sequence(name,seq);

CREATE TABLE second(d,e,f);

CREATE INDEX first_index ON first(a,b);

CREATE VIEW third AS SELECT d,e FROM second}

    test schema-1.2 {Lists persistent schema with pattern} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            CREATE TABLE second(d,e,f);
            CREATE INDEX first_index ON first(a,b);
            CREATE VIEW third AS SELECT d,e FROM second;
        }
    } -body {
        sqlib schema $db first*
    } -cleanup {
        $db close
    } -result {CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);

CREATE INDEX first_index ON first(a,b)}

    test schema-1.3 {Lists temporary schema} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            CREATE TEMP TABLE third(g,h,i);
        }
    } -body {
        sqlib schema $db 
    } -cleanup {
        $db close
    } -result {CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);

CREATE TABLE sqlite_sequence(name,seq);

CREATE TABLE third(g,h,i)}

    test schema-1.4 {Lists temporary schema with wildcard} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            CREATE TEMP TABLE third(g,h,i);
        }
    } -body {
        sqlib schema $db *ird
    } -cleanup {
        $db close
    } -result {CREATE TABLE third(g,h,i)}


    #-------------------------------------------------------------------
    # schema

    test clear-1.1 {Clears non-sqlite entities from db} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            CREATE TABLE second(d,e,f);
            CREATE INDEX first_index ON first(a,b);
            CREATE VIEW third AS SELECT d,e FROM second;
        }
    } -body {
        sqlib clear $db
        $db eval {SELECT type, name FROM sqlite_master}
    } -cleanup {
        $db close
    } -result {table sqlite_sequence}

    test clear-1.2 {Clears temporary non-sqlite entities from db} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TEMP TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            CREATE TEMP TABLE second(d,e,f);
            CREATE INDEX first_index ON first(a,b);
            CREATE TEMP VIEW third AS SELECT d,e FROM second;
        }
    } -body {
        sqlib clear $db
        $db eval {SELECT type, name FROM sqlite_temp_master}
    } -cleanup {
        $db close
    } -result {table sqlite_sequence}

    test clear-1.3 {Deletes entries from sqlite entities in db} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE first(a INTEGER PRIMARY KEY AUTOINCREMENT,b,c);
            INSERT INTO first(b) VALUES(1);
            INSERT INTO first(b) VALUES(2);
        }
    } -body {
        sqlib clear $db
        $db eval {SELECT * FROM sqlite_sequence}
    } -cleanup {
        $db close
    } -result {}

    #-------------------------------------------------------------------
    # compare

    # TBD, however it has been manually tested on large RDBs.

    #-------------------------------------------------------------------
    # saveas
    
    # TBD, hwoever it has been manually tested on large RDBs.

    #-------------------------------------------------------------------
    # query

    # TBD, however it has been thoroughly exercised in practice.


    #-------------------------------------------------------------------
    # mat

    # TBD

    #-------------------------------------------------------------------
    # insert

    test insert-1.1 {Inserts dict into table} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE mytable(a,b,c);
        }
    } -body {
        sqlib insert $db mytable {
            a "The First" 
            b "The Second"
            c "The Third"
        }

        $db eval {SELECT * FROM mytable} row {}
        array get row
    } -result {a {The First} b {The Second} * {a b c} c {The Third}}


    #-------------------------------------------------------------------
    # replace

    test replace-1.1 {Inserts dict into table} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE mytable(a,b,c);
        }
    } -body {
        sqlib replace $db mytable {
            a "The First" 
            b "The Second"
            c "The Third"
        }

        $db eval {SELECT * FROM mytable} row {}
        array get row
    } -result {a {The First} b {The Second} * {a b c} c {The Third}}

    test replace-1.2 {Replaces dict in table} -setup {
        sqlite3 $db :memory:

        $db eval {
            CREATE TABLE mytable(a TEXT PRIMARY KEY,b,c);
        }

        sqlib insert $db mytable {
            a "The First" 
            b "The Second"
            c "The Third"
        }

    } -body {
        sqlib replace $db mytable {
            a "The First" 
            b "The New Second"
            c "The New Third"
        }

        $db eval {SELECT * FROM mytable} row {}
        array get row
    } -result {a {The First} b {The New Second} * {a b c} c {The New Third}}

    #-------------------------------------------------------------------
    # grab

    test grab-1.1 {grabs nothing if no table is given} -setup {
        sqlite3 $db :memory:
    } -body {
        sqlib grab $db
    } -result {}

    test grab-1.2 {grabs nothing if table is empty} -setup {
        sqlite3 $db :memory:
        $db eval {CREATE TABLE mytable(a,b,c)}
    } -body {
        sqlib grab $db mytable {}
    } -result {}

    test grab-1.3 {grabs nothing if all rows are excluded} -setup {
        sqlite3 $db :memory:
        $db eval {CREATE TABLE mytable(a,b,c)}
        sqlib insert $db mytable {a 1 b 2 c 3}
    } -body {
        sqlib grab $db mytable {a=2}
    } -result {}

    test grab-1.4 {grabs all rows from table} -setup {
        sqlite3 $db :memory:
        $db eval {CREATE TABLE mytable(a,b,c)}
        sqlib insert $db mytable {a 1 b 2 c 3}
        sqlib insert $db mytable {a 4 b 5 c 6}
    } -body {
        sqlib grab $db mytable {}
    } -result {mytable {1 2 3 4 5 6}}

    test grab-1.5 {grabs particular row from table} -setup {
        sqlite3 $db :memory:
        $db eval {CREATE TABLE mytable(a,b,c)}
        sqlib insert $db mytable {a P b Q c R}
        sqlib insert $db mytable {a X b Y c Z}
    } -body {
        sqlib grab $db mytable {b='Y'}
    } -result {mytable {X Y Z}}

    test grab-1.6 {grab condition includes variable} -setup {
        sqlite3 $db :memory:
        $db eval {CREATE TABLE mytable(a,b,c)}
        sqlib insert $db mytable {a P b Q c R}
        sqlib insert $db mytable {a X b Y c Z}
    } -body {
        set a P
        sqlib grab $db mytable {a=$a}
    } -result {mytable {P Q R}}

    test grab-1.7 {grab from multiple tables} -setup {
        sqlite3 $db :memory:
        $db eval {CREATE TABLE tablex(x1,x2,x3)}
        $db eval {CREATE TABLE tabley(y1,y2,y3)}
        sqlib insert $db tablex {x1 A x2 B x3 C}
        sqlib insert $db tablex {x1 D x2 E x3 F}
        sqlib insert $db tabley {y1 G y2 H y3 I}
        sqlib insert $db tabley {y1 J y2 K y3 L}
    } -body {
        set x1 D
        set y2 K
        sqlib grab $db tablex {x1=$x1} tabley {y2=$y2}
    } -result {tablex {D E F} tabley {J K L}}

    #-------------------------------------------------------------------
    # ungrab

    test ungrab-1.1 {does nothing if no data} -setup {
        sqlite3 $db :memory:
        $db eval {CREATE TABLE tablex(x1,x2,x3)}
    } -body {
        sqlib ungrab $db
        sqlib query $db {SELECT * FROM tablex}
    } -result {}

    test ungrab-1.2 {inserts into tables} -setup {
        sqlite3 $db :memory:
        $db eval {CREATE TABLE tablex(x1 TEXT PRIMARY KEY,x2,x3)}
    } -body {
        sqlib ungrab $db tablex {
            A B C
            D E F
        }
        sqlib query $db {SELECT * FROM tablex}
    } -result {x1 x2 x3 
-- -- -- 
A  B  C  
D  E  F  
}

    test ungrab-1.3 {replaces in tables} -setup {
        sqlite3 $db :memory:
        $db eval {CREATE TABLE tablex(x1 TEXT PRIMARY KEY,x2,x3)}
        sqlib ungrab $db tablex {
            A B C
            D E F
        }
    } -body {
        sqlib ungrab $db tablex {
            A P Q
            D R S
        }
        sqlib query $db {SELECT * FROM tablex}
    } -result {x1 x2 x3 
-- -- -- 
A  P  Q  
D  R  S  
}

    #-------------------------------------------------------------------
    # Cleanup

    cleanupTests
}

namespace delete ::marsutil::test







