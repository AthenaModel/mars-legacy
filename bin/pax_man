#!/bin/sh
# -*-tcl-*-
# The next line restarts using tclsh \
exec tclsh8.5 "$0" "$@"

#-----------------------------------------------------------------------
# TITLE:
#    pax_man
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    This program is a document processor for pax_man(5) man page
#    format.  pax_man(5) man pages are written in "Extended HTML", 
#    i.e., HTML extended with Tcl macros.  It automatically generates
#    tables of contents, etc., and provides easy linking to other
#    man pages.
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# External Packages

# From Tcllib
package require textutil::expander

#-------------------------------------------------------------------
# Paxsim packages

set bindir [file dirname [info script]]
set auto_path [linsert $auto_path 0 [file join $bindir .. lib]]

package require paxutil 1.0
namespace import paxutil::*

#-----------------------------------------------------------------------
# Expander
# 
# Create the Expander, and add global commands so that the environment
# resembles that of the standalone Expand tool.

# Namespace for the expander add-ons.
namespace eval ::exp:: {
    # Which pass we're on
    variable pass 0
}

textutil::expander theExpander
theExpander lb "<<"
theExpander rb ">>"

# Return the right and left brackets, for HTML output
proc lb {}                { return "&lt;&lt;" }
proc rb {}                { return "&gt;&gt;" }
proc exppass {}           { return $::exp::pass }
proc cget {varname}       { theExpander cget $varname }
proc cpop {cname}         { theExpander cpop $cname }
proc cpush {cname}        { theExpander cpush $cname }
proc cset {varname value} { theExpander cset $varname $value }

# Process a file and return the expanded output.

proc expandFile {name} {
    # Pass 1 -- for indexing
    set f [open $name]
    set input [read $f]
    close $f

    set ::exp::pass 1
    theExpander expand $input

    set ::exp::pass 2
    return [theExpander expand $input]
}

# Converts a generic string to an ID string.  Leading and trailing
# whitespace and internal punctuation is removed, internal whitespace
# is converted to "_", and the text is converted to lower case.
proc textToID {text} {
    # First, trim any white space and convert to lower case
   set text [string trim [string tolower $text]]

    # Next, substitute "_" for internal whitespace, and delete any
    # non-alphanumeric characters (other than "_", of course)
    regsub -all {[ ]+} $text "_" text
    regsub -all {[^a-z0-9_/]} $text "" text

    return $text
}

#=======================================================================
# General EHTML Processing

# PAX Version Number
set version x.y.z 

# Source directory
set srcdir "."

# Destination directory
set destdir "."

# Manpage section title
set sectionTitle ""

# The relative URL for man pages.
set manurl ".."

# An array of additional xref links
array set xreflinks {}

# An array: key is module name, value is list of submodules.
# modules with no parent are under submodule().
variable submodule

# An array: key is module name, value is description.
variable module

# Mktree script flag
variable mktreeFlag 0

#-----------------------------------------------------------------------
# Simple Macros

# Recursive expansion

proc expand {text} {
    return [theExpander expand $text]
}

# The relative URL for man pages
proc manurl {} {return $::manurl}

# Makes a string nonbreaking, normalizing spaces.
proc nbsp {text} {
    set text [string trim $text]
    regsub {\s\s+} $text " " text

    return [string map {" " &nbsp;} $text]
}

template hrule {} {<p><hr></p>}

template link {url {anchor ""}} {
    if {$anchor eq ""} {
        set anchor $url
    }
} {<a href="$url">$anchor</a>}


#-----------------------------------------------------------------------
# Cross-references

# Define an ad-hoc cross reference
proc xrefset {id anchor url} {
    variable xreflinks

    set xreflinks($id) [list $anchor $url]

    # Return nothing, so that this can be used in macros.
    return ""
}

# xref: link to a section or manpage.
proc xref {id {anchor ""}} {
    variable xreflinks

    if {[exppass] == 1} {
        return
    }

    set subtopic {}

    if {[info exists xreflinks($id)]} {
        set url [lindex $xreflinks($id) 1]
        set defaultAnchor [lindex $xreflinks($id) 0]
    } elseif {[regexp {^([^()]+)\(([1-9in])\)$} $id dummy name section]} {
        set url "[manurl]/man$section/$name.html"
        set defaultAnchor $id
        set subtopic "#[textToID $anchor]"
    } elseif {[string match "http:*" $id]} {
        set url $id
        set defaultAnchor $id
    } elseif {[lsearch -exact $::sections $id] != -1} {
        set url "#[textToID $id]"
        set defaultAnchor $id
    } else {
        puts "Warning: xref: unknown id '$id'"
        return "[lb]xref $id[rb]"
    }

    if {$anchor eq ""} {
        set anchor $defaultAnchor
    }

    return "<a href=\"$url$subtopic\">$anchor</a>"
} 

#-------------------------------------------------------------------
# Javascripts

# If included in man page, the mktree script is included
proc mktree {} {
    variable mktreeFlag

    set mktreeFlag 1

    return
}

set mktreeScript {
<script language="javascript">
//===================================================================
//Author: Matt Kruse <matt@mattkruse.com>
//WWW: http://www.mattkruse.com/
//
//NOTICE: You may use this code for any purpose, commercial or
//private, without any further permission from the author. You may
//remove this notice from your final code if you wish, however it is
//appreciated by the author if at least my web site address is kept.
//
//You may *NOT* re-distribute this code in any way except through its
//use. That means, you can include it in your product, or your web
//site, or any other form where the code is actually being used. You
//may not put the plain javascript up on your site for download or
//include it in your javascript libraries for download.
//If you wish to share this code with others, please just point them
//to the URL instead.
//Please DO NOT link directly to my .js files from your site. Copy
//the files to your server and use them there. Thank you.
//===================================================================
//HISTORY
//------------------------------------------------------------------
//December 9, 2003: Added script to the Javascript Toolbox
//December 10, 2003: Added the preProcessTrees variable to allow user
//     to turn off automatic conversion of UL's onLoad
//March 1, 2004: Changed it so if a <li> has a class already attached
//     to it, that class won't be erased when initialized. This allows
//     you to set the state of the tree when painting the page simply
//     by setting some <li>'s class name as being "liOpen" (see example)
/*
This code is inspired by and extended from Stuart Langridge's aqlist code:
        http://www.kryogenix.org/code/browser/aqlists/
        Stuart Langridge, November 2002
        sil@kryogenix.org
        Inspired by Aaron's labels.js (http://youngpup.net/demos/labels/)
        and Dave Lindquist's menuDropDown.js (http://www.gazingus.org/dhtml/?id=109)
*/

//Automatically attach a listener to the window onload, to convert the trees
addEvent(window,"load",convertTrees);

//Utility function to add an event listener
function addEvent(o,e,f){
    if (o.addEventListener){ o.addEventListener(e,f,true); return true; }
    else if (o.attachEvent){ return o.attachEvent("on"+e,f); }
    else { return false; }
}

//utility function to set a global variable if it is not already set
function setDefault(name,val) {
    if (typeof(window[name])=="undefined" || window[name]==null) {
        window[name]=val;
    }
}

//Full expands a tree with a given ID
function expandTree(treeId) {
    var ul = document.getElementById(treeId);
    if (ul == null) { return false; }
    expandCollapseList(ul,nodeOpenClass);
}

//Fully collapses a tree with a given ID
function collapseTree(treeId) {
    var ul = document.getElementById(treeId);
    if (ul == null) { return false; }
    expandCollapseList(ul,nodeClosedClass);
}

//Expands enough nodes to expose an LI with a given ID
function expandToItem(treeId,itemId) {
    var ul = document.getElementById(treeId);
    if (ul == null) { return false; }
    var ret = expandCollapseList(ul,nodeOpenClass,itemId);
    if (ret) {
        var o = document.getElementById(itemId);
        if (o.scrollIntoView) {
            o.scrollIntoView(false);
        }
    }
}

//Performs 3 functions:
//a) Expand all nodes
//b) Collapse all nodes
//c) Expand all nodes to reach a certain ID
function expandCollapseList(ul,cName,itemId) {
    if (!ul.childNodes || ul.childNodes.length==0) { return false; }
    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var item = ul.childNodes[itemi];
        if (itemId!=null && item.id==itemId) { return true; }
        if (item.nodeName == "LI") {
            // Iterate things in this LI
            var subLists = false;
            for (var sitemi=0;sitemi<item.childNodes.length;sitemi++) {
                var sitem = item.childNodes[sitemi];
                if (sitem.nodeName=="UL") {
                    subLists = true;
                    var ret = expandCollapseList(sitem,cName,itemId);
                    if (itemId!=null && ret) {
                        item.className=cName;
                        return true;
                    }
                }
            }
            if (subLists && itemId==null) {
                item.className = cName;
            }
        }
    }
}

//Search the document for UL elements with the correct CLASS name, then process them
function convertTrees() {
    setDefault("treeClass","mktree");
    setDefault("nodeClosedClass","liClosed");
    setDefault("nodeOpenClass","liOpen");
    setDefault("nodeBulletClass","liBullet");
    setDefault("nodeLinkClass","bullet");
    setDefault("preProcessTrees",true);
    if (preProcessTrees) {
        if (!document.createElement) { return; } // Without createElement, we can't do anything
        uls = document.getElementsByTagName("ul");
        for (var uli=0;uli<uls.length;uli++) {
            var ul=uls[uli];
            if (ul.nodeName=="UL" && ul.className==treeClass) {
                processList(ul);
            }
        }
    }
}

//Process a UL tag and all its children, to convert to a tree
function processList(ul) {
    if (!ul.childNodes || ul.childNodes.length==0) { return; }
    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var item = ul.childNodes[itemi];
        if (item.nodeName == "LI") {
            // Iterate things in this LI
            var subLists = false;
            for (var sitemi=0;sitemi<item.childNodes.length;sitemi++) {
                var sitem = item.childNodes[sitemi];
                if (sitem.nodeName=="UL") {
                    subLists = true;
                    processList(sitem);
                }
            }
            var s= document.createElement("SPAN");
            var t= "";
            s.className = nodeLinkClass;
            if (subLists) {
                // This LI has UL's in it, so it's a +/- node
                if (item.className==null || item.className=="") {
                    item.className = nodeClosedClass;
                    t = "+\u00A0";
                }
                if (item.className==nodeOpenClass) {
                    t = "\u2013\u00A0";
                }
                // If it's just text, make the text work as the link also
                if (item.firstChild.nodeName=="#text") {
                    t = t+item.firstChild.nodeValue;
                    item.removeChild(item.firstChild);
                }
                s.onclick = function () {
                    this.parentNode.className = (this.parentNode.className==nodeOpenClass) ? nodeClosedClass : nodeOpenClass;
                    this.firstChild.nodeValue = (this.firstChild.nodeValue=="+\u00A0") ? "\u2013\u00A0" : "+\u00A0";
                    return false;
                }
            }
            else {
                // No sublists, so it's just a bullet node
                item.className = nodeBulletClass;
                s.onclick = function () { return false; }
                t = "\u2022\u00A0";
            }
            s.appendChild(document.createTextNode(t));
            item.insertBefore(s,item.firstChild);
        }
    }
}
</script>
}



#=======================================================================
# Manpages

variable items {}        ;# List of item tags, in order of definition 
variable itemtext        ;# Array, item text by tag
variable sections {}     ;# List of section names, in order of definition.
variable curSection {}   ;# Current section
variable subsections     ;# Array of subsection names by parent section.

template manpage {nameList description} {
    variable items
    variable itemtext
    variable sections
    variable curSection
    variable subsections
    variable module
    variable submodule
    variable optsfor
    variable opttext
    variable mktreeFlag
    variable mktreeScript

    set name [lindex $nameList end]

    if {[llength $nameList] > 1} {
        set parent [lindex $nameList 0]
        set parentRef ", submodule of [xref $parent]"
        set titleParentRef ", submodule of $parent"
    } else {
        set parent ""
        set parentRef ""
        set titleParentRef ""
    }

    if {[exppass] == 1} {
        set items {}
        array unset itemtext
        array unset optsfor
        array unset opttext
        set sections {}
        array unset subsections
        set curSection {}
        set module($name) $description
        lappend submodule($parent) $name
    }
} {
    |<--
    <html>
    <head>
    <title>PAX $::version: $name -- $description$titleParentRef</title>
    <style type="text/css" media="screen,print">
    a {
        text-decoration: none;
    }
    body {
        color: black;
        background: white;
        margin-left: 6%;
        margin-right: 6%;
    }
    h2 {
        margin-left: -5%;
    }
    hr {
        margin-left: -5%;
    }
    pre {
        background:     #FFFF99 ;
        border:         1px solid blue;
        padding-top:    2px;
        padding-bottom: 2px;
        padding-left:   4px;
    }
    table {
        margin-top:    4px;
        margin-bottom: 4px;
    }
    th {
        padding-left: 4px;
    }
    td {
        padding-left: 4px;
    }
    
    [tif {$mktreeFlag} {
        |<--
        /* mktree styles */
        ul.mktree  li  { list-style: none; }
        ul.mktree, ul.mktree ul, ul.mktree li { 
            margin-left:10px; padding:0px; }
        ul.mktree li .bullet { padding-left: 10px }
        ul.mktree  li.liOpen   .bullet {cursor : pointer; }
        ul.mktree  li.liClosed .bullet {cursor : pointer; }
        ul.mktree  li.liBullet .bullet {cursor : default; }
        ul.mktree  li.liOpen   ul {display: block; }
        ul.mktree  li.liClosed ul {display: none; }
    }]
    </style>
    
    [tif {$mktreeFlag} {
        |<--
        $mktreeScript
    }]

    </head>

    <body>
    [section NAME]

    $name -- $description$parentRef
    
    [contents]
}

template /manpage {} {
    |<--
    <hr>
    <i>PAX $::version Man page generated by pax_man(1) on 
    [clock format [clock seconds]]</i>
    </body>
    </html>
}

template section {name} {
    variable sections
    variable curSection

    set name [string toupper $name]
    set id [textToID $name]
    if {[exppass] == 1} {
        lappend sections $name 
    }

    set curSection $name
} {
    |<--
    <h2><a name="$id">$name</a></h2>
}

template subsection {name} {
    variable curSection
    variable subsections

    set id [textToID $name]
    if {[exppass] == 1} {
        lappend subsections($curSection) $name 
        xrefset $name $name "#$id"
    }
} {
    |<--
    <h2><a name="$id">$name</a></h2>
}

template contents {} {
    variable sections
    variable subsections
} {
    |<--
    <ul>
    [tforeach name $sections {
        <li><a href="#[textToID $name]">$name</a></li>
        [tif {[info exists subsections($name)]} {
            |<--
            <ul>
            [tforeach subname $subsections($name) {
                <li><a href="#[textToID $subname]">$subname</a></li>
            }]
            </ul>
        }]
    }]
    </ul>
}

# The args don't matter, but can be used as comments.
template deflist {args} {
    |<--
    <dl>
}

# The args don't matter, but can be used as comments.
template /deflist {args} {
    |<--
    </dl>
}

template defitem {item text} {
    variable items
    variable itemtext

    lappend items $item
    set itemtext($item) $text
} {
    |<--
    <dt><b><tt><a name="[textToID $item]">$text</a></tt></b></dt>
    <dd>
}

template itemlist {} {
    variable items
    variable itemtext
    variable optsfor
    variable opttext
} {
    |<--
    [tforeach tag $items {
        |<--
        <tt><a href="#[textToID $tag]">$itemtext($tag)</a></tt><br>
        [tif {[info exists optsfor($tag)]} {
            |<--
            [tforeach opt $optsfor($tag) {
                |<--
                &nbsp;&nbsp;&nbsp;&nbsp;
                <tt><a href="#$tag$opt">$opttext($tag$opt)</a></tt><br>
            }]
        }]
    }]<p>
}

proc iref {args} {
    variable items
    variable itemtext
    variable opttext

    set tag $args

    if {[exppass] == 1} {
        return
    }

    if {[lsearch -exact $items $tag] != -1} {
        return "<tt><a href=\"#[textToID $tag]\">$tag</a></tt>"
    } else {
        puts stderr "Warning, iref not found: '$tag'"
        return "<tt>$tag</tt>"
    }
}

template defopt {text} {
    variable items
    variable optsfor
    variable opttext

    set opt [lindex $text 0]
    set lastItem [lindex $items end]
    set id "$lastItem$opt"
    lappend optsfor($lastItem) $opt
    set opttext($id) $text
} {
    |<--
    <dt><b><tt><a name="$id">$text</a></tt></b></dt>
    <dd>
}

#-----------------------------------------------------------------------
# Index file template

template indexfile {} {
    set title "PAX $::version Man Pages: $::sectionTitle"
} {
    |<--
    <head>
    <title>$title</title>
    <style>
    body {
        color: black;
        background: white;
        margin-left: 5%;
        margin-right: 5%;
    }
    </style>
    </head>
    <body>
    <h2>$title</h2>
    <hr>

    [indexlist $::submodule()]

    <hr>
    <i>Index generated by pax_man on [clock format [clock seconds]]</i>
    </body>
    </html>
}

template indexlist {modules} {
    |<--
    <ul>
    [tforeach module [lsort $modules] {
    |<--
        <li>
        [xref $module]: $::module($module)
        [tif {[info exists ::submodule($module)]} {
            |<--
            [indexlist $::submodule($module)]
        }]
        </li>
           
    }]
    </ul>
}




#=======================================================================
# Main line code

proc showhelp {} {
    puts {Usage: pax_man [options...]

Options:
    -version x.y.z             Project version number
    -srcdir <path>             Source directory.
    -destdir <path>            Destination directory.
    -section <title>           Man page section title

For each file.ehtml in the source directory, produces file.html in the 
destination directory.  Both source and destination default to the
current working directory.
}
}

proc main {argv} {
    while {[string match "-*" [lindex $argv 0]]} {
        set opt [lindex $argv 0]
        set val [lindex $argv 1]
        set argv [lrange $argv 2 end]
        
        switch -exact -- $opt {
            -version {
                set ::version $val
            }
            -destdir {
                if {![file exists $val] && [file isdirectory $val]} {
                    puts stderr "Error: '$val' is not a valid directory."
                    exit 1
                }
                set ::destdir $val
            }
            -srcdir {
                if {![file exists $val] && [file isdirectory $val]} {
                    puts stderr "Error: '$val' is not a valid directory."
                    exit 1
                }
                set ::srcdir $val
            }
            -section {
                set ::sectionTitle $val
            }
            default {
                puts stderr "Unknown option: '$opt'."

                showhelp
                exit 1
            }
        }
    }

    if {[llength $argv] != 0} {
        showhelp
        exit 1
    }

    set files [glob -nocomplain $::srcdir/*.ehtml]

    if {[llength $files] == 0} {
        showhelp
        exit
    }

    foreach infile $files {
        set manfile [file tail [file root $infile]].html
        set outfile [file join $::destdir $manfile]

        if {[catch {expandFile $infile} output]} {
            puts stderr $output
            exit 1
        }

        set f [open $outfile w]
        puts $f $output
        close $f
    }

    # NEXT, output the index
    set outfile [file join $::destdir index.html]
    set f [open $outfile w]
    puts $f [indexfile]
    close $f
}

#-----------------------------------------------------------------------
# Run the program

main $argv









