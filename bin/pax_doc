#!/bin/sh
# -*-tcl-*-
# The next line restarts using tclsh \
exec tclsh8.5 "$0" "$@"

#-----------------------------------------------------------------------
# TITLE:
#	pax_doc
#
# AUTHOR:
#	Will Duquette
#
# DESCRIPTION:
#       This program is a document processor for Extended HTML, i.e.,
#       HTML extended with Tcl macros.  It provides automatic section
#       numbering and generates tables of contents and lists of 
#	figures and tables; it also provides easy linking to sections,
#	figures, tables, and man pages.
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# External Packages

# From Tcllib
package require textutil::expander

#-------------------------------------------------------------------
# Paxsim packages

set bindir [file dirname [info script]]
set auto_path [linsert $auto_path 0 [file join $bindir .. lib]]

package require paxutil 1.0
namespace import paxutil::*

# Expander
# 
# Create the Expander, and add global commands so that the environment
# resembles that of the standalone Expand tool.

# Namespace for the expander add-ons.
namespace eval ::exp:: {
    # Which pass we're on
    variable pass 0
}

textutil::expander theExpander
theExpander lb "<<"
theExpander rb ">>"


# Return the right and left brackets.
proc lb {}                { theExpander lb }
proc rb {}                { theExpander rb }
proc exppass {}           { return $::exp::pass }
proc cget {varname}       { theExpander cget $varname }
proc cpop {cname}         { theExpander cpop $cname }
proc cpush {cname}        { theExpander cpush $cname }
proc cset {varname value} { theExpander cset $varname $value }

# Process a file and return the expanded output.

proc expandFile {name} {
    # Pass 1 -- for indexing
    set f [open $name]
    set input [read $f]
    close $f

    set ::exp::pass 1
    theExpander expand $input

    set ::exp::pass 2
    return [theExpander expand $input]
}

#=======================================================================
# EHTML Definition Rules
#
# Reset these if the delivery or environment changes.

# The document root directory
# TBD: set this via a command-line option; for now, assume the
# document is in the jnem/docs directory.

set docRoot .

# An array of additional xref links
array set xreflinks {}

#-----------------------------------------------------------------------
# Data tables

# HTML header levels by section header level.  Note that section level
# 0 is for unnumbered sections.

array set hn {
    0 h2
    1 h2
    2 h3
    3 h4
    4 h4
    5 h4
    6 h4
}

set css {
    a {
        text-decoration: none;
    }
    body {
        color: black;
        background: white;
        margin-left: 6%;
        margin-right: 6%;
    }
    pre {
        background:     #FFFF99 ;
        border:         1px solid blue;
        padding-top:    2px;
        padding-bottom: 2px;
        padding-left:   4px;
    }
    table {
        margin-top:    4px;
        margin-bottom: 4px;
        width:         100%;
    }
    th {
        padding-left: 4px;
    }
    td {
        padding-left: 4px;
    }
}

#-----------------------------------------------------------------------
# Document Structure
#
# A document consists of the following elements:
#
# * A table of contents, which may be located anywhere in the document
#   but conventionally goes at the beginning.
#
# * Zero or more "preface" sections.  A preface section has a title but
#   no section number, and cannot have children.
#
# * Zero or more numbered sections, each of which may have zero or more
#   subsections, etc.
#
# * Numbered sections may contain figures and tables.
#
# Every preface, section, figure, and table has an anchor ID, which
# has the following form:
#
# Type     Form
# -------  ---------------------------------------------------------
# preface  <token>
# section  <token>[.<token>[.<token>...]]    
# table    tab.<token>
# figure   fig.<token>


#-----------------------------------------------------------------------
# Document Data
#
# Every location in the document that can be linked to has an anchor ID:
# a single token which can be used in [xref...] calls.  By convention,
# section IDs use dot notation.  For example, a toplevel section called
# "Introduction" might have an ID like "intro". Subsections of this 
# section would have IDs like "intro.this" and "intro.that", and so on.
#
# Every section has a level, 0 through 5.  Level 0 sections lack section
# numbers, and are necessarily toplevel.  Level 1 sections have a section 
# number like "1."; level 2 sections a number like "1.1", and so on.

# This is the array that holds all of the section indexing data.  The
variable doc

# Initialize the table of contents data.  The sectionlist is a list 
# of the valid section IDs.  The levels list is a list of section
# numbers by level.

proc resetForNextDocument {} {
    variable doc

    set doc(anchors) {}
    set doc(levels) [list dummy 0 0 0 0 0 0]
    set doc(topsections) {}
    set doc(tables) {}
    set doc(figures) {}
}


# The schema is as follows:
# 
# Index                    Description
# -----------------------  ---------------------------------------------
# anchors                  A list of valid anchor IDs, in the order of
#                          appearance in the document.
#
# topsections              A list of valid anchor IDs for toplevel sections.
# tables                   A list of valid anchor IDs for tables.
# figures                  A list of valid anchor IDs for figures.
#
# levels                   This is a list of the current section numbers
#                          at each level.  For example, if we just saw
#                          section 1.2.3, this will be the list
#                  
#                              dummy 1 2 3 0 0 0
#
# current-$n               This list contains the anchor ID of the current
#                          section at each section level.  Thus, when
#                          we've just seen section a.b.c, the array will contain
#                          these entries:
#
#                             current-1 a
#                             current-2 a.b
#                             current-3 a.b.c
#
# tablecounter             Number of last table in this major section
# figurecounter            Number of last figure in this major section
#
# children-$id             A list of the anchor IDs of the children of
#                          section $id.
#
# title-$id                Complete title for anchor $id, e.g.,
#                          "1.1 References".
# link-$id                 Link text for anchor $id e.g., "Section 1.1"
# 

#-----------------------------------------------------------------------
# Utility commands

# Use in pass 1 to save section ID.
#
# level:  type of the header: preface or numbered.
# id:     HTML anchor ID
# title:  section title

proc addSectionId {type id title} {
    variable doc

    # FIRST, validate the ID.
    if {[lsearch -exact $doc(anchors) $id] != -1} {
        error "Duplicate section id: '$id'"
    }

    if {![regexp {\w+(\.\w+)*} $id]} {
        error "Invalid section id: '$id', should be '<token>\[.<token>...\]'"
    }

    # NEXT, determine the level.  For preface, it's 0; for 
    # normal sections, it's 1 plus the number of periods.
    set numPeriods [countPeriods $id]

    if {$type eq "preface"} {
        if {$numPeriods > 0} {
            error "Invalid preface id: '$id', should be '<token>'"
        }

        set level 0
        set doc(level-$id) $level
        set doc(current-1) $id
        lappend doc(topsections) $id
    } else {
        set level [expr {$numPeriods + 1}]

        set doc(level-$id) $level

        if {$level == 1} {
            set doc(current-1) $id
            lappend doc(topsections) $id
        } else {
            set doc(current-$level) $id
            set plevel [expr {$level - 1}]
            set parent $doc(current-$plevel)

            if {![string match "$parent.*" $id]} {
                set goodparent [file rootname $id]
                error "Invalid section ID: '$id'; parent is '$parent', should be '$goodparent'"
            }

            lappend doc(children-$parent) $id
        }
    }


    lappend doc(anchors) $id
    set doc(children-$id) {}

    if {$level == 0 || $level == 1} {
        set doc(tablecounter) 0
        set doc(figurecounter) 0
    }

    if {$level == 0} {
        set doc(title-$id) $title
        set doc(link-$id) $title
        return
    }

    # Increment the section number at this level and 0 the lower levels.
    set max [llength $doc(levels)]

    for {set i $level} {$i < $max} {incr i} {
        if {$i == $level} {
            set secnum [lindex $doc(levels) $i]
            incr secnum
            lset doc(levels) $i $secnum
        } else {
            lset doc(levels) $i 0
        }
    }

    # Next format link and title for the section.
    if {$level == 1} {
        set number "[lindex $doc(levels) 1]"
        set doc(title-$id) "$number. $title"
        set doc(link-$id) "Section $number"
    } else {
        set number "[lindex $doc(levels) 1]"
        for {set i 2} {$i <= $level} {incr i} {
            append number ".[lindex $doc(levels) $i]"
        }
        set doc(title-$id) "$number $title"
        set doc(link-$id) "Section $number"
    }
}

# Counts the number of periods in a name.
proc countPeriods {id} {
    set count 0
    foreach c [split $id ""] {
        if {$c eq "."} {
            incr count
        }
    }

    return $count
}

# Use in pass 1 to save table ID.
#
# id is the string to use as the HTML anchor text.
proc addTableId {id title} {
    variable doc

    if {[lsearch -exact $doc(anchors) $id] != -1} {
        error "Duplicate table id: '$id'"
    }

    if {![regexp {tab\.\w+} $id]} {
        error "Invalid table id: '$id'; should be 'tab.<token>'"
    }

    lappend doc(anchors) $id
    lappend doc(tables) $id


    # Get the section number of the parent toplevel section.
    set secnum [lindex $doc(levels) 1]

    if {$secnum == 0} {
        error "Table appears outside of numbered section: $id"
    }

    # Get the number of this table
    set tabnum [incr doc(tablecounter)]

    set doc(title-$id) "Table $secnum-$tabnum: $title"
    set doc(link-$id) "Table $secnum-$tabnum"
}

# Use in pass 1 to save figure ID.
#
# id is the string to use as the HTML anchor text.
proc addFigureId {id title} {
    variable doc

    if {[lsearch -exact $doc(anchors) $id] != -1} {
        error "Duplicate figure id: '$id'"
    }

    if {![regexp {fig\.\w+} $id]} {
        error "Invalid figure id: '$id'; should be 'fig.<token>'"
    }


    lappend doc(anchors) $id
    lappend doc(figures) $id


    # Get the section number of the parent toplevel section.
    set secnum [lindex $doc(levels) 1]

    if {$secnum == 0} {
        error "Figure appears outside of numbered section: $id"
    }

    # Get the number of this table
    set fignum [incr doc(figurecounter)]

    set doc(title-$id) "Figure $secnum-$fignum: $title"
    set doc(link-$id) "Figure $secnum-$fignum"
}

#-----------------------------------------------------------------------
# Simple Macros

# The current Paxsim version
# TBD: Should be settable by the caller
proc version {} {
    global env

    if {![info exists env(PAX_VERSION)]} {
        return x.y.z
    } else {
        return $env(PAX_VERSION)
    }
}

# Paxsim Banner
# TBD: Should be settable by the caller
template banner {} {
    <h1 style="background: red;">&nbsp;Paxsim: Simulation Infrastructure</h1>
}

# The URL for Paxsim man pages
# TBD: Should be settable by the caller.
# We'll probably need a list of man page directories.
proc manurl {} {return $::docRoot}

# Makes a string nonbreaking, normalizing spaces.
proc nbsp {text} {
    set text [string trim $text]
    regsub {\s\s+} $text " " text

    return [string map {" " &nbsp;} $text]
}

template hrule {} {<p><hr></p>}

template link {url {anchor ""}} {
    if {$anchor eq ""} {
        set anchor $url
    }
} {<a href="$url">$anchor</a>}

proc standardstyle {} {
    global css
    return $css
}

#-----------------------------------------------------------------------
# Section headers

# Formats a section header; not for use in documents.
# type is "preface" or "numbered"
template sectiondef {type id title} {
    variable doc
    variable hn

    if {[exppass] == 1} {
        addSectionId $type $id $title
        return
    }

    set level $doc(level-$id)
    set title $doc(title-$id)
} {
    |<--

    <$hn($level)><a name="$id" href="#toc.$id">$title</a></$hn($level)>
}

# Format section headers.

proc preface {id title} {return [sectiondef preface $id $title]}
proc section {id title} {return [sectiondef numbered $id $title]}

#-----------------------------------------------------------------------
# Table formatting

# Begins a table
template table {id title} {
    variable doc

    if {[exppass] == 1} {
        addTableId $id $title
        return
    }
} {
    |<--
    <center><table border="1" cellpadding="2" cellspacing="0">
    <caption><b><a name="$id" href="#toc.$id">$doc(title-$id)</a><b></caption>
}

# Ends a table
template /table {} {
    |<--
    </table></center><p>
}

#-----------------------------------------------------------------------
# Figure formatting

# Includes a figure
template figure {id title filename} {
    variable doc

    if {[exppass] == 1} {
        addFigureId $id $title
        return
    }
} {
    <p><a name="$id" href="#toc.$id"><center><img src="./$filename"><br/>
       <b>$doc(title-$id)</b></center></a></p>
}

#-----------------------------------------------------------------------
# Cross-references

# Define an ad-hoc cross reference
proc xrefset {id anchor url} {
    variable xreflinks

    set xreflinks($id) [list $anchor $url]

    # Return nothing, so that this can be used in macros.
    return ""
}

# xref: link to a section or manpage.
proc xref {id {anchor ""}} {
    variable doc
    variable xreflinks

    if {[exppass] == 1} {
        return
    }

    if {[info exists xreflinks($id)]} {
        set url [lindex $xreflinks($id) 1]
        set defaultAnchor [lindex $xreflinks($id) 0]
    } elseif {[regexp {^([^()]+)\(([1-9in])\)$} $id dummy name section]} {
        set url "[manurl]/man$section/$name.html"
        set defaultAnchor $id
    } elseif {[info exists doc(title-$id)]} {
        set url "#$id"
        set defaultAnchor $doc(link-$id)
    } elseif {[string match "http:*" $id]} {
        set url $id
        set defaultAnchor $id
    } else {
        error "xref: unknown section id '$id'"
    }

    if {$anchor eq ""} {
        set anchor $defaultAnchor
    }

    return "<a href=\"$url\">$anchor</a>"
} 

# table of contents
template contents {} {
    variable doc

    if {[exppass] == 1} {
        return
    }
} {
    |<--
    <h2>Table of Contents</h2>

    [tforeach id $doc(topsections) {
        |<--
        <p><b><a href="#$id" name="toc.$id">$doc(title-$id)</a></b></p>

        [sectioncontents $doc(children-$id)]
    }]

    [tables]
    [figures]
    </ul>
}


template sectioncontents {seclist} {
    variable doc
    
    if {[llength $seclist] == 0} {
        return ""
    }
} {
    |<--
    <ul>
    [tforeach id $seclist {
        <li><a href="#$id" name="toc.$id">$doc(title-$id)</a></li>

        [sectioncontents $doc(children-$id)]
    }]
    </ul>
}

template tables {} {
    variable doc

    if {[exppass] == 1} {
        return
    }

    if {[llength $doc(tables)] == 0} {
        return ""
    }
} {
    |<--
    <h2>List of Tables</h2>
    <ul>
    [tforeach id $doc(tables) {
        <li><a href="#$id" name="toc.$id">$doc(title-$id)</a></li>
    }]
    </ul>
}

template figures {} {
    variable doc

    if {[exppass] == 1} {
        return
    }

    if {[llength $doc(figures)] == 0} {
        return ""
    }
} {
    |<--
    <h2>List of Figures</h2>
    <ul>
    [tforeach id $doc(figures) {
        <li><a href="#$id" name="toc.$id">$doc(title-$id)</a></li>
    }]
    </ul>
}

# table of anchors.  This routine writes all of the anchors to
# stdout.
proc anchors {} {
    variable doc

    if {[exppass] == 1} {
        return
    }

    # FIRST, determine the maximum anchor length
    set len 0
    foreach id $doc(anchors) {
        set alen [string length $id]

        # Figures and tables are indented by four spaces; allow for it.
        if {[string match "fig.*" $id] ||
            [string match "tab.*" $id]} {
            incr alen 4
        }
        if {$alen > $len} {
            set len $alen
        }
    }

    # NEXT, format the format string.
    set fmt "%-${len}s  %s"

    # NEXT, output the list anchors
    foreach id $doc(anchors) {
        # If it's a figure or table, indent by four spaces.
        if {[string match "fig.*" $id] ||
            [string match "tab.*" $id]} {
            set displayId "    $id"
        } else {
            set displayId $id
        }

        puts [format $fmt $displayId $doc(title-$id)]
    }

    return ""
}

#-----------------------------------------------------------------------
# Change Log

# Begins a change log 
template changelog {} {
    |<--
    <table border width="100%" cellpadding="2" cellspacing="0">
    <tr>
    <th align="left" width="10%">Status</th>
    <th width="70%">Nature of Change</th>
    <th align="left" width="10%">Date</th>
    <th align="left" width="10%">Initiator</th>
    </tr>
}

# Ends a change log
template /changelog {} {
    |<--
    </table><p>
}

# Begins a change entry
proc change {date status initiator} {
    cpush change
    cset date [nbsp $date]
    cset status [nbsp $status]
    cset initiator [nbsp $initiator]
    return
}

# Ends a change entry
template /change {} {
    set date [cget date]
    set status [cget status]
    set initiator [cget initiator]

    set description [cpop change]
} {
    |<--
    <tr valign=top>
    <td>$status</td>
    <td>$description</td>
    <td>$date</td>
    <td>$initiator</td>
    </tr>
}

#-----------------------------------------------------------------------
# Main line code

proc showhelp {} {
    puts "Usage: pax_doc \[options\] file.ehtml..."
    puts ""
    puts "-docroot <relpath>    Top docs directory relative to file.ehtml"
    puts ""
    puts "Given file.ehtml, produces file.html in the same directory."
}

while {[string match "-*" [lindex $argv 0]]} {
    set opt [lindex $argv 0]
    set val [lindex $argv 1]
    set argv [lrange $argv 2 end]

    switch -exact -- $opt {
        -docroot {
            set ::docRoot $val
        }
        default {
            puts stderr "Unknown option: '$opt'."

            showhelp
            exit 1
        }
    }
}

if {[llength $argv] < 1} {
    showhelp
    exit 1
}

foreach infile $argv {
    resetForNextDocument

    set outfile [file rootname $infile].html

    if {[catch {expandFile $infile} output]} {
        puts stderr $output
        exit 1
    }

    set f [open $outfile w]
    puts $f $output
    close $f

    puts "Wrote $outfile"
}






